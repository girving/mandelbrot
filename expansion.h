// Higher precision floating point numbers via expansion arithmetic
#pragma once

#include <ostream>
#include <span>
namespace mandelbrot {

// References:
//   Shewchuk 1997, Adaptive precision floating-point arithmetic and fast robust geometric predicates
//     https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
//   Lu et al. 2020, Supporting extended precision on graphics processors
//     https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.707.4321&rep=rep1&type=pdf
//   Collange et al. 2016, Parallel floating-point expansions for extended-precision GPU computations
//     https://hal.archives-ouvertes.fr/hal-01298206/document

struct Arb;
struct Arf;
using std::string;
using std::ostream;

struct Nonoverlap {};
constexpr Nonoverlap nonoverlap;

template<int n> struct Expansion {
  static_assert(n >= 2);
  double x[n];  // Ulp-nonoverlapping in decreasing order of magnitude

  Expansion() : x{0} {}

  // These promise that the nonoverlapping invariant already holds
  Expansion(double x0, double x1, Nonoverlap) : x{x0, x1} { static_assert(n == 2); }
  Expansion(double x0, double x1, double x2, Nonoverlap) : x{x0, x1, x2} { static_assert(n == 3); }
  Expansion(double x0, double x1, double x2, double x3, Nonoverlap) : x{x0, x1, x2, x3} { static_assert(n == 4); }

  // These are slow
  explicit operator bool() const;
  bool operator==(const Expansion y) const;
  std::span<const double> span() const;
  Arf exact_arf() const;  // Dangerous if the exponents are far apart
  Arb arb(const int prec) const;
};

// Dangerous if the exponents are far apart, since it calls exact_arf()
template<int n> ostream& operator<<(ostream& out, const Expansion<n> e);

}  // namespace mandelbrot

// Pull in autogenerated codelets
#include "gen/expansion.h"
