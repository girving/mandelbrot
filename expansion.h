// Higher precision floating point numbers via expansion arithmetic
#pragma once

#include "arith.h"
#include "span.h"
#include <cmath>
#include <ostream>
namespace mandelbrot {

// References:
//   Shewchuk 1997, Adaptive precision floating-point arithmetic and fast robust geometric predicates
//     https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
//   Lu et al. 2020, Supporting extended precision on graphics processors
//     https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.707.4321&rep=rep1&type=pdf
//   Collange et al. 2016, Parallel floating-point expansions for extended-precision GPU computations
//     https://hal.archives-ouvertes.fr/hal-01298206/document

struct Arb;
struct Arf;
using std::string;
using std::ostream;

struct Nonoverlap {};
constexpr Nonoverlap nonoverlap;

template<int n> struct Expansion {
  struct Unusable {};
  static_assert(n >= 2);
  double x[n];  // Ulp-nonoverlapping in decreasing order of magnitude

  Expansion() : x{0} {}
  Expansion(Unusable*) : x{0} {}  // Allow construction from literal 0

  // These promise that the nonoverlapping invariant already holds
  Expansion(double x0, double x1, Nonoverlap) : x{x0, x1} { static_assert(n == 2); }
  Expansion(double x0, double x1, double x2, Nonoverlap) : x{x0, x1, x2} { static_assert(n == 3); }
  Expansion(double x0, double x1, double x2, double x3, Nonoverlap) : x{x0, x1, x2, x3} { static_assert(n == 4); }

  // Conversion from smaller types
  explicit Expansion(const double a) : x{a, 0} {}
  explicit Expansion(const int32_t a) : x{double(a), 0} {}
  explicit Expansion(const int64_t a) : x{0} { x[0] = a; x[1] = a - int64_t(x[0]); }
  void operator=(const int32_t a) { x[0] = a; for (int i = 1; i < n; i++) x[i] = 0; }

  // In place arithmetic
  void operator+=(const int y) { *this = *this + Expansion(y); }
  void operator-=(const int y) { *this = *this - Expansion(y); }
  void operator+=(const Expansion y) { *this = *this + y; }
  void operator-=(const Expansion y) { *this = *this - y; }

  // Multiplication by integers which might be too big to fit in a double
  friend Expansion operator*(const int64_t a, const Expansion x) { return Expansion(a) * x; }

  // Division via Newton iteration
  Expansion operator/(const Expansion b) const;
  Expansion operator/(const int64_t b) const { return *this / Expansion(b); }

  // Componentwise-safe operations
  #define CWISE(op) Expansion y; for (int i = 0; i < n; i++) y.x[i] = op; return y;
  friend Expansion half(const Expansion x) { CWISE(mandelbrot::half(x.x[i])) }
  friend Expansion twice(const Expansion x) { CWISE(mandelbrot::twice(x.x[i])) }
  friend Expansion ldexp(const Expansion x, const int e) { CWISE(std::ldexp(x.x[i], e)) }
  #undef CWISE

  bool operator==(const int a) const {
    double e = a;
    for (int i = 0; i < n; i++)
      e -= x[i];
    return e == 0;
  }

  explicit operator double() const {
    double s = x[n-1];
    for (int i = n-2; i >= 0; i--)
      s += x[i];
    return s;
  }

  // These are slow
  explicit operator bool() const;
  bool operator==(const Expansion y) const;
  bool operator!=(const Expansion y) const { return !(*this == y); }
  SPAN_NAMESPACE::span<const double> span() const;
  Arb arb(const int prec) const;
  explicit Expansion(const string& s);
};

template<int n> int sign(const Expansion<n> x);
template<int n> Expansion<n> abs(const Expansion<n> x);
template<int n> Expansion<n> inv(const Expansion<n> x);

// For now, don't try to optimize sqr further
template<int n> Expansion<n> sqr(const Expansion<n> x) { return x * x; }

// Dangerous if the exponents are far apart
template<int n> Arb exact_arb(const Expansion<n> x);
template<int n> Arf exact_arf(const Expansion<n> x);

// Dangerous if the exponents are far apart, since it calls exact_arf()
template<int n> ostream& operator<<(ostream& out, const Expansion<n> e);

// Print enough digits for exact reconstruction
template<int n> string safe(const Expansion<n> x);

}  // namespace mandelbrot

// Pull in autogenerated codelets
#include "gen/expansion.h"
